"""MySQL Property Repository - Adapter for data persistence"""
import logging
from typing import Any

from app.database import db_connection
from app.domain.ports.property_repository import IPropertyRepository

logger = logging.getLogger(__name__)


class MySQLPropertyRepository(IPropertyRepository):
    """
    Repository implementation for accessing property data from MySQL.
    
    Implements IPropertyRepository port.
    Executes raw SQL queries (generated by LLM) on MySQL database.
    """

    async def search(self, sql: str) -> list[dict[str, Any]]:
        """
        Execute a search query on the properties database.
        
        Args:
            sql: SQL SELECT query to execute
            
        Returns:
            List of property records as dictionaries
            
        Raises:
            ValueError: If SQL execution fails
            RuntimeError: If database connection fails
        """
        try:
            logger.debug(f"Executing query: {sql[:100]}...")
            
            # Execute query using database connection manager
            results = await db_connection.execute_query(sql)
            
            logger.info(f"✓ Query executed successfully, returned {len(results)} rows")
            
            return results
            
        except RuntimeError as e:
            logger.error(f"✗ Database error during query execution: {str(e)}")
            raise
            
        except Exception as e:
            logger.error(f"✗ Unexpected error during query execution: {str(e)}", exc_info=True)
            raise RuntimeError(f"Failed to execute search query: {str(e)}")

    async def get_by_id(self, property_id: int) -> dict[str, Any] | None:
        """
        Get a single property by ID.
        
        Args:
            property_id: ID of the property
            
        Returns:
            Property record as dictionary, or None if not found
        """
        try:
            sql = f"SELECT * FROM propiedades WHERE id = {property_id}"
            results = await self.search(sql)
            
            return results[0] if results else None
            
        except Exception as e:
            logger.error(f"Failed to get property by ID {property_id}: {str(e)}")
            raise

    async def count(self) -> int:
        """
        Get total count of properties.
        
        Returns:
            Total number of properties in database
        """
        try:
            sql = "SELECT COUNT(*) as total FROM propiedades"
            results = await self.search(sql)
            
            return results[0]['total'] if results else 0
            
        except Exception as e:
            logger.error(f"Failed to count properties: {str(e)}")
            raise

    async def get_available_tipos(self) -> list[str]:
        """
        Get list of available property types.
        
        Returns:
            List of property types (casa, departamento, terreno, etc.)
        """
        try:
            sql = "SELECT DISTINCT tipo FROM propiedades WHERE estado = 'activa' ORDER BY tipo"
            results = await self.search(sql)
            
            return [row['tipo'] for row in results] if results else []
            
        except Exception as e:
            logger.error(f"Failed to get property types: {str(e)}")
            raise

    async def get_zonas_disponibles(self) -> list[str]:
        """
        Get list of available zonas/ubicaciones.
        
        Returns:
            List of administrative zones
        """
        try:
            sql = "SELECT DISTINCT zona_administrativa FROM propiedades WHERE zona_administrativa IS NOT NULL AND estado = 'activa' ORDER BY zona_administrativa"
            results = await self.search(sql)
            
            return [row['zona_administrativa'] for row in results] if results else []
            
        except Exception as e:
            logger.error(f"Failed to get available zones: {str(e)}")
            raise

    async def get_price_range(self) -> dict[str, float]:
        """
        Get price range statistics.
        
        Returns:
            Dictionary with min_price, max_price, avg_price
        """
        try:
            sql = "SELECT MIN(precio) as min_price, MAX(precio) as max_price, AVG(precio) as avg_price FROM propiedades WHERE estado = 'activa'"
            results = await self.search(sql)
            
            if results:
                row = results[0]
                return {
                    "min_price": float(row['min_price'] or 0),
                    "max_price": float(row['max_price'] or 0),
                    "avg_price": float(row['avg_price'] or 0),
                }
            
            return {"min_price": 0, "max_price": 0, "avg_price": 0}
            
        except Exception as e:
            logger.error(f"Failed to get price range: {str(e)}")
            raise
